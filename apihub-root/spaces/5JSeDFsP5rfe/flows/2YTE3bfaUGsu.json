{"name":"GenerateDocument","content":"({\n            start: async function(title, topic, chaptersCount, personalityId, maxTokens){\n                let personalityPrompt;\n                if(personalityId){\n                    let personality = webSkel.currentUser.space.getPersonality(personalityId);\n                    personalityPrompt = `Step into the shoes of ${personality.name}, a character known for their distinctive traits: ${personality.description}. Your mission is to respond to the following prompt in such a way that it encapsulates the distinct essence of this character. Don't reiterate ${personality.name}'s traits in your answer. `;\n                }\n                this.setDefaultValues();\n                this.setIntelligenceLevel(3);\n                let schema = await this.generateSchema(title, topic, chaptersCount, personalityPrompt);\n                let chapters = await this.generateChapters(schema, personalityPrompt);\n                let mainIdeas = await this.generateMainIdeas(chapters, personalityPrompt);\n                let abstract = await this.generateAbstract(mainIdeas, personalityPrompt);\n                await this.addDocument(title, topic, chapters, mainIdeas, abstract);\n\n            },\n            generateSchema: async function(title, topic, chaptersCount, personalityPrompt){\n                const documentSchemaPrompt = `${personalityPrompt || \"\"}Please generate a schema for a document. The topic of this document is ${topic} and it should have ${chaptersCount} chapters. The title is ${title}. The schema should have the following format: {\"title\": \"Title of the document\",\"chapters\": [${countChapters(chaptersCount)}]}`;\n                function countChapters(chaptersCount) {\n                    let chapters = '';\n                    for (let i = 0; i < chaptersCount; i++) {\n                        chapters += `{\"title\": \"Chapter ${i} title\",\"mainIdeas\": [\"Chapter ${i} idea 1\", \"Chapter ${i} idea 2\", ..., \"Chapter ${i} idea n\"]}`;\n                        if (i <= chaptersCount) {\n                            chapters += ', ';\n                        }\n                    }\n                    return chapters;\n                }\n                let schema = await this.request(documentSchemaPrompt);\n                try{\n                    return JSON.parse(schema);\n                }catch(e){\n                    this.fail(e);\n                }\n            },\n            generateChapters: async function(schema, personalityPrompt){\n                let generatedChapters = [];\n                let previousChapters;\n                for(let i= 0; i < schema.chapters.length; i++){\n                    if(i> 0){\n                        const includedAttributes = ['title', 'mainIdeas'];\n                        let minimizedChapters = generatedChapters.map(obj => {\n                            // Using object destructuring and filter to keep only specified attributes\n                            return Object.fromEntries(\n                                Object.entries(obj).filter(([key]) => includedAttributes.includes(key))\n                            );\n                        });\n                        previousChapters = `Use a logical flow in your generation and continue your writing flow using these previous chapters and their main ideas:${JSON.stringify(minimizedChapters)}.`;\n                    }\n                    let generateChapterPrompt = `${personalityPrompt || \"\"}Please generate a chapter that is strictly related to these main ideas: ${JSON.stringify(schema.chapters[i].mainIdeas)} and this title:${schema.chapters[i].title}. ${previousChapters || \"\"} The chapter should have the following structure:{\"title\":\"Chapter Title\", \"mainIdeas\":[\"paragraph 1 summary\", \"paragraph 2 summary\", ... , \"paragraph n summary\"], \"paragraphs\":[{text:\"paragraph 1 text\", mainIdea:\"paragraph 1 summary\"}, {text:\"paragraph 2 text\", mainIdea:\"paragraph 2 summary\"}, ... {text:\"paragraph n text\", mainIdea:\"paragraph n summary\"}]}.`;\n                    let response = await this.request(generateChapterPrompt);\n                    try{\n                        generatedChapters.push(JSON.parse(response));\n                    }catch(e){\n                        this.fail(e);\n                    }\n                }\n                return generatedChapters;\n            },\n            generateMainIdeas: async function(chapters, personalityPrompt){\n                let mainIdeas = [];\n                for(let chapter of chapters){\n                    let prompt = `${personalityPrompt || \"\"}Please summarize these ideas: ${JSON.stringify(chapter.mainIdeas)} into a single idea. Return only the idea`;\n                    let response = await this.request(prompt);\n                    mainIdeas.push(response);\n                }\n                return mainIdeas;\n            },\n            generateAbstract: async function(mainIdeas, personalityPrompt){\n                let prompt = `${personalityPrompt || \"\"}Please create an abstract for a document that has these main ideas: ${JSON.stringify(mainIdeas)}. Return only the abstract text`;\n                return await this.request(prompt);\n            },\n            addDocument: async function(title, topic, chapters, mainIdeas, abstract){\n                let documentData = {\n                    title:title,\n                    topic:topic,\n                    chapters: chapters,\n                    mainIdeas: mainIdeas,\n                    abstract: abstract\n                }\n                await webSkel.currentUser.space.addDocument(documentData);\n            }\n        });","id":"2YTE3bfaUGsu","description":"Generates a whole document based on: a title, a topic, number of chapters","tags":["documents","agents","presenters"]}