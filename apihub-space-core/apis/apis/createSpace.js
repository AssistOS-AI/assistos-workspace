async function createSpace(spaceName, userId, apiKey) {

    const path = require('path');
    const fsPromises = require('fs').promises;

    const {
        generateId,
        createDefaultAnnouncement,
        templateReplacer_$$,
        getCurrentUTCDate,
        createDirectory,
        maskOpenAIKey,
        validateData,
        copyDefaultFlows,
        copyDefaultPersonalities,
        createSpaceStatus
    } = require('../exporter.js')
    ('generateId', 'createDefaultAnnouncement', 'templateReplacer_$$', 'getCurrentUTCDate', 'createDirectory', 'maskOpenAIKey', 'validateData', 'copyDefaultFlows', 'copyDefaultPersonalities', 'createSpaceStatus');

    const {
        defaultSpaceTemplate,
        defaultApiKeyTemplate,
        defaultSpaceAgent
    } = require('../../models/templates/exporter.js')
    ('defaultSpaceTemplate', 'defaultApiKeyTemplate', 'defaultSpaceAgent');

    const spaceValidationSchema = require('../../models/validation-schemas/exporter.js')
    ('spaceValidationSchema');

    const {SPACE_FOLDER_PATH} = require('../../config.json');

    const spaceId = generateId();
    let spaceObj = {}
    try {
        spaceObj = templateReplacer_$$(defaultSpaceTemplate, {
            spaceName: spaceName,
            spaceId: spaceId,
            adminId: userId,
            apiKey: templateReplacer_$$(defaultApiKeyTemplate, {
                keyType: "OpenAI",
                userId: userId,
                keyId: generateId(),
                keyValue: maskOpenAIKey(apiKey)
            }),
            spaceAgent: defaultSpaceAgent,
            defaultAnnouncement: createDefaultAnnouncement(spaceName),
            creationDate: getCurrentUTCDate()
        });
    } catch (e) {
        const error = new Error('Error creating space');
        error.statusCode = 500;
        throw error;
    }
    let spaceValidationResult = {};
    try {
        spaceValidationResult = validateData(spaceValidationSchema, spaceObj);
    } catch (e) {
        const error = new Error('Error validating space data');
        error.statusCode = 500;
        throw error;
    }
    if (spaceValidationResult.status === false) {
        const error = new Error(spaceValidationResult.errorMessage);
        error.statusCode = 400;
        throw error;
    }
    const rollback = async () => {
        if (fsPromises.access(spacePath)) {
            if (fsPromises.rmdir) {
                await fsPromises.rmdir(spacePath, {recursive: true})
            } else if (fsPromises.rm) {
                await fsPromises.rm(spacePath, {recursive: true})
            } else {
                const error = new Error('Error reverting changes generated by Space Creation');
                error.statusCode = 500;
                throw error;
            }
        }
    }

    const spacePath = path.join(__dirname, '../../../', `${SPACE_FOLDER_PATH}`, `${spaceId}`);

    try {
        await  createDirectory(spacePath);
        const filesPromises = [
            copyDefaultFlows(spacePath),
            copyDefaultPersonalities(spacePath),
            createDirectory(path.join(spacePath, 'documents')),
            createDirectory(path.join(spacePath, 'applications')),
            createSpaceStatus(spacePath, spaceObj),
        ]
        await Promise.all(filesPromises);
        return spaceObj;
    } catch (e) {
        await rollback();
        throw e;
    }
}

module.exports = createSpace;